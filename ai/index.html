<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a1a2e">
  <meta name="description" content="Privacy-focused voice-to-AI assistant">
  <title>Audio Assistant</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="icon.svg">
  <style>
    /* ===== CSS Reset & Base ===== */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --accent: #e94560;
      --accent-dim: #a33347;
      --text-primary: #eaeaea;
      --text-secondary: #a0a0a0;
      --text-muted: #606060;
      --border: #2a2a4e;
      --success: #4ade80;
      --warning: #fbbf24;
      --error: #ef4444;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
    }

    /* ===== Main Layout ===== */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 900px;
      margin: 0 auto;
    }

    /* ===== Response Area (Main Content) ===== */
    .response-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      padding: 24px 20px;
      overflow: hidden;
    }

    .response-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-shrink: 0;
    }

    .provider-badge {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 12px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .history-nav {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .history-nav.hidden {
      visibility: hidden;
    }

    .history-counter {
      font-size: 12px;
      color: var(--text-muted);
    }

    .nav-btn {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px 10px;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .nav-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .response-content {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      background: var(--bg-secondary);
      border-radius: 16px;
      font-size: 17px;
      line-height: 1.7;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .response-content.empty {
      color: var(--text-muted);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 16px;
    }

    .empty-icon {
      font-size: 48px;
      opacity: 0.5;
    }

    .empty-text {
      font-size: 15px;
    }

    .response-content.loading {
      color: var(--text-secondary);
    }

    .loading-dots::after {
      content: '';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {
      0% { content: ''; }
      25% { content: '.'; }
      50% { content: '..'; }
      75% { content: '...'; }
    }

    /* ===== Bottom Bar ===== */
    .bottom-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .record-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .record-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--bg-tertiary);
      border: 2px solid var(--border);
      border-radius: 24px;
      color: var(--text-primary);
      cursor: pointer;
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .record-btn:hover {
      border-color: var(--accent);
    }

    .record-btn.recording {
      background: var(--accent);
      border-color: var(--accent);
    }

    .record-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--text-muted);
      transition: background 0.2s ease;
    }

    .record-btn.recording .record-dot {
      background: white;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.3); }
    }

    .keyboard-hint {
      font-size: 12px;
      color: var(--text-muted);
    }

    kbd {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: inherit;
      font-size: 11px;
    }

    .settings-btn {
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 10px 16px;
      font-size: 14px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .settings-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* ===== Transcript Overlay ===== */
    .transcript-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 500;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      padding: 20px;
    }

    .transcript-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .transcript-modal {
      background: var(--bg-secondary);
      border-radius: 20px 20px 0 0;
      width: 100%;
      max-width: 700px;
      max-height: 50vh;
      display: flex;
      flex-direction: column;
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }

    .transcript-overlay.active .transcript-modal {
      transform: translateY(0);
    }

    .transcript-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .transcript-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .recording-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      animation: pulse 1.5s ease-in-out infinite;
    }

    .transcript-actions {
      display: flex;
      gap: 8px;
    }

    .transcript-btn {
      background: var(--bg-tertiary);
      border: none;
      border-radius: 8px;
      color: var(--text-primary);
      cursor: pointer;
      padding: 8px 16px;
      font-size: 13px;
      transition: all 0.2s ease;
    }

    .transcript-btn:hover {
      background: var(--accent);
    }

    .transcript-btn.send {
      background: var(--accent);
    }

    .transcript-btn.send:hover {
      background: var(--accent-dim);
    }

    .transcript-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      font-size: 20px;
      color: var(--text-primary);
      min-height: 100px;
    }

    .transcript-content.empty {
      color: var(--text-muted);
      font-style: italic;
    }

    .transcript-content .interim {
      color: var(--text-secondary);
      opacity: 0.7;
    }

    /* ===== Modal ===== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      padding: 20px;
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--bg-secondary);
      border-radius: 16px;
      width: 100%;
      max-width: 500px;
      max-height: 85vh;
      overflow-y: auto;
      transform: scale(0.95);
      transition: transform 0.2s ease;
    }

    .modal-overlay.active .modal {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: var(--bg-secondary);
      z-index: 1;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 600;
    }

    .modal-close {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 24px;
      line-height: 1;
      padding: 4px;
    }

    .modal-close:hover {
      color: var(--text-primary);
    }

    .modal-body {
      padding: 24px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }

    .form-input, .form-select, .form-textarea {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }

    .form-input:focus, .form-select:focus, .form-textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .form-select {
      cursor: pointer;
    }

    .form-textarea {
      resize: vertical;
      min-height: 80px;
    }

    .form-hint {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .form-hint.error {
      color: var(--error);
    }

    .form-hint.success {
      color: var(--success);
    }

    .input-with-btn {
      display: flex;
      gap: 8px;
    }

    .input-with-btn .form-input {
      flex: 1;
    }

    .btn-refresh {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 0 14px;
      font-size: 18px;
      transition: all 0.2s ease;
    }

    .btn-refresh:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .btn-refresh.loading {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .provider-config {
      display: none;
    }

    .provider-config.active {
      display: block;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--accent-dim);
    }

    .btn-block {
      width: 100%;
    }

    /* ===== Toast ===== */
    .toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 20px;
      font-size: 14px;
      z-index: 2000;
      opacity: 0;
      transition: all 0.3s ease;
    }

    .toast.active {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    .toast.error {
      border-color: var(--error);
      color: var(--error);
    }

    .toast.success {
      border-color: var(--success);
      color: var(--success);
    }

    /* ===== Browser Warning ===== */
    .browser-warning {
      position: fixed;
      inset: 0;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      z-index: 3000;
    }

    .browser-warning.hidden {
      display: none;
    }

    .warning-content {
      max-width: 400px;
    }

    .warning-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .warning-title {
      font-size: 20px;
      margin-bottom: 12px;
    }

    .warning-text {
      color: var(--text-secondary);
      font-size: 14px;
    }

    /* ===== Scrollbar ===== */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /* ===== Responsive ===== */
    @media (max-width: 600px) {
      .keyboard-hint {
        display: none;
      }
      
      .response-content {
        font-size: 15px;
        padding: 16px;
      }
      
      .transcript-content {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <!-- Browser Warning -->
  <div class="browser-warning hidden" id="browserWarning">
    <div class="warning-content">
      <div class="warning-icon">‚ö†Ô∏è</div>
      <h2 class="warning-title">Browser Not Supported</h2>
      <p class="warning-text">
        This app requires the Web Speech API which is not supported in your browser. 
        Please use Chrome, Edge, or Safari for the best experience.
      </p>
    </div>
  </div>

  <!-- Main App -->
  <div class="app">
    <!-- Response Area -->
    <section class="response-area">
      <div class="response-header">
        <span class="provider-badge" id="providerBadge">Ollama</span>
        <div class="history-nav hidden" id="historyNav">
          <button class="nav-btn" id="prevBtn" title="Previous (‚Üë)">‚Üê</button>
          <span class="history-counter" id="historyCounter">1 / 1</span>
          <button class="nav-btn" id="nextBtn" title="Next (‚Üì)">‚Üí</button>
        </div>
      </div>
      <div class="response-content empty" id="responseContent">
        <div class="empty-icon">üéôÔ∏è</div>
        <div class="empty-text">
          Press <kbd>Space</kbd> to start recording<br>
          or click the Record button below
        </div>
      </div>
    </section>

    <!-- Bottom Bar -->
    <div class="bottom-bar">
      <div class="record-section">
        <button class="record-btn" id="recordBtn">
          <span class="record-dot"></span>
          <span id="recordBtnText">Record</span>
        </button>
        <span class="keyboard-hint"><kbd>Space</kbd> to toggle</span>
      </div>
      <button class="settings-btn" id="settingsBtn">
        <span>‚öôÔ∏è</span>
        <span>Settings</span>
      </button>
    </div>
  </div>

  <!-- Transcript Overlay -->
  <div class="transcript-overlay" id="transcriptOverlay">
    <div class="transcript-modal">
      <div class="transcript-header">
        <div class="transcript-title">
          <span class="recording-indicator"></span>
          <span>Listening...</span>
        </div>
        <div class="transcript-actions">
          <button class="transcript-btn" id="cancelBtn">Cancel</button>
          <button class="transcript-btn send" id="sendBtn">Send</button>
        </div>
      </div>
      <div class="transcript-content empty" id="transcriptContent">
        Start speaking...
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title" id="settingsTitle">Settings</h2>
        <button class="modal-close" id="settingsClose">&times;</button>
      </div>
      <div class="modal-body">
        <div class="setup-welcome hidden" id="setupWelcome">
          <p style="margin-bottom: 16px; color: var(--text-secondary);">
            Configure your AI provider to get started. Your settings are stored locally in your browser.
          </p>
        </div>
        <div class="form-group">
          <label class="form-label">AI Provider</label>
          <select class="form-select" id="providerSelect">
            <option value="ollama">Ollama (Local)</option>
            <option value="lmstudio">LM Studio (Local)</option>
            <option value="gemini">Google Gemini</option>
            <option value="openai">OpenAI</option>
          </select>
        </div>

        <!-- Ollama Config -->
        <div class="provider-config active" id="ollamaConfig">
          <div class="form-group">
            <label class="form-label">Ollama URL</label>
            <div class="input-with-btn">
              <input type="text" class="form-input" id="ollamaUrl" value="http://localhost:11434" placeholder="http://localhost:11434">
              <button type="button" class="btn-refresh" id="refreshModelsBtn" title="Refresh models">‚Üª</button>
            </div>
            <div class="form-hint">Set OLLAMA_ORIGINS=* to allow browser access</div>
          </div>
          <div class="form-group">
            <label class="form-label">Model</label>
            <select class="form-select" id="ollamaModel">
              <option value="">Loading models...</option>
            </select>
            <div class="form-hint" id="ollamaModelHint">Fetching available models from Ollama...</div>
          </div>
        </div>

        <!-- LM Studio Config -->
        <div class="provider-config" id="lmstudioConfig">
          <div class="form-group">
            <label class="form-label">LM Studio URL</label>
            <div class="input-with-btn">
              <input type="text" class="form-input" id="lmstudioUrl" value="http://localhost:1234" placeholder="http://localhost:1234">
              <button type="button" class="btn-refresh" id="refreshLmstudioModelsBtn" title="Refresh models">‚Üª</button>
            </div>
            <div class="form-hint">Start LM Studio's local server first</div>
          </div>
          <div class="form-group">
            <label class="form-label">Model</label>
            <select class="form-select" id="lmstudioModel">
              <option value="">Loading models...</option>
            </select>
            <div class="form-hint" id="lmstudioModelHint">Fetching available models from LM Studio...</div>
          </div>
        </div>

        <!-- Gemini Config -->
        <div class="provider-config" id="geminiConfig">
          <div class="form-group">
            <label class="form-label">API Key</label>
            <input type="password" class="form-input" id="geminiApiKey" placeholder="Enter your Gemini API key">
            <div class="form-hint">Get your key at ai.google.dev</div>
          </div>
          <div class="form-group">
            <label class="form-label">Model</label>
            <select class="form-select" id="geminiModel">
              <option value="gemini-pro">Gemini Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
            </select>
          </div>
        </div>

        <!-- OpenAI Config -->
        <div class="provider-config" id="openaiConfig">
          <div class="form-group">
            <label class="form-label">API Key</label>
            <input type="password" class="form-input" id="openaiApiKey" placeholder="Enter your OpenAI API key">
            <div class="form-hint">Get your key at platform.openai.com</div>
          </div>
          <div class="form-group">
            <label class="form-label">Model</label>
            <select class="form-select" id="openaiModel">
              <option value="gpt-4o">GPT-4o</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">System Prompt</label>
          <textarea class="form-textarea" id="systemPrompt" placeholder="Instructions for the AI..."></textarea>
          <div class="form-hint">Customize how the AI responds</div>
        </div>

        <button class="btn btn-primary btn-block" id="saveSettings">Save Settings</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <script>
    // ===== Default System Prompt =====
    const DEFAULT_SYSTEM_PROMPT = `You are a helpful voice assistant. Keep your responses brief and conversational - ideally 1-3 sentences unless more detail is specifically requested. Be direct and avoid unnecessary preamble.`;

    // ===== App State =====
    const state = {
      isRecording: false,
      isProcessing: false,
      isFirstRun: true,
      transcript: '',
      interimTranscript: '',
      history: [],
      historyIndex: -1,
      recognition: null,
      config: {
        provider: 'ollama',
        ollamaUrl: 'http://localhost:11434',
        ollamaModel: '',
        lmstudioUrl: 'http://localhost:1234',
        lmstudioModel: '',
        geminiApiKey: '',
        geminiModel: 'gemini-pro',
        openaiApiKey: '',
        openaiModel: 'gpt-4o',
        systemPrompt: DEFAULT_SYSTEM_PROMPT
      }
    };

    // ===== DOM Elements =====
    const elements = {
      browserWarning: document.getElementById('browserWarning'),
      providerBadge: document.getElementById('providerBadge'),
      responseContent: document.getElementById('responseContent'),
      historyNav: document.getElementById('historyNav'),
      historyCounter: document.getElementById('historyCounter'),
      prevBtn: document.getElementById('prevBtn'),
      nextBtn: document.getElementById('nextBtn'),
      recordBtn: document.getElementById('recordBtn'),
      recordBtnText: document.getElementById('recordBtnText'),
      settingsBtn: document.getElementById('settingsBtn'),
      transcriptOverlay: document.getElementById('transcriptOverlay'),
      transcriptContent: document.getElementById('transcriptContent'),
      cancelBtn: document.getElementById('cancelBtn'),
      sendBtn: document.getElementById('sendBtn'),
      settingsModal: document.getElementById('settingsModal'),
      settingsTitle: document.getElementById('settingsTitle'),
      settingsClose: document.getElementById('settingsClose'),
      setupWelcome: document.getElementById('setupWelcome'),
      providerSelect: document.getElementById('providerSelect'),
      ollamaConfig: document.getElementById('ollamaConfig'),
      lmstudioConfig: document.getElementById('lmstudioConfig'),
      geminiConfig: document.getElementById('geminiConfig'),
      openaiConfig: document.getElementById('openaiConfig'),
      ollamaUrl: document.getElementById('ollamaUrl'),
      ollamaModel: document.getElementById('ollamaModel'),
      ollamaModelHint: document.getElementById('ollamaModelHint'),
      refreshModelsBtn: document.getElementById('refreshModelsBtn'),
      lmstudioUrl: document.getElementById('lmstudioUrl'),
      lmstudioModel: document.getElementById('lmstudioModel'),
      lmstudioModelHint: document.getElementById('lmstudioModelHint'),
      refreshLmstudioModelsBtn: document.getElementById('refreshLmstudioModelsBtn'),
      geminiApiKey: document.getElementById('geminiApiKey'),
      geminiModel: document.getElementById('geminiModel'),
      openaiApiKey: document.getElementById('openaiApiKey'),
      openaiModel: document.getElementById('openaiModel'),
      systemPrompt: document.getElementById('systemPrompt'),
      saveSettings: document.getElementById('saveSettings'),
      toast: document.getElementById('toast')
    };

    // ===== Browser Compatibility Check =====
    function checkBrowserSupport() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        elements.browserWarning.classList.remove('hidden');
        return false;
      }
      return true;
    }

    // ===== LocalStorage =====
    function loadSettings() {
      try {
        const saved = localStorage.getItem('audioAssistant');
        if (saved) {
          const data = JSON.parse(saved);
          Object.assign(state.config, data.config || {});
          state.history = data.history || [];
          state.isFirstRun = false;
          // Set default system prompt if empty
          if (!state.config.systemPrompt) {
            state.config.systemPrompt = DEFAULT_SYSTEM_PROMPT;
          }
        } else {
          state.isFirstRun = true;
          state.config.systemPrompt = DEFAULT_SYSTEM_PROMPT;
        }
      } catch (e) {
        console.error('Failed to load settings:', e);
        state.isFirstRun = true;
        state.config.systemPrompt = DEFAULT_SYSTEM_PROMPT;
      }
      updateUIFromConfig();
    }

    function saveSettings() {
      try {
        const data = {
          config: state.config,
          history: state.history.slice(-50)
        };
        localStorage.setItem('audioAssistant', JSON.stringify(data));
      } catch (e) {
        console.error('Failed to save settings:', e);
      }
    }

    function updateUIFromConfig() {
      elements.providerSelect.value = state.config.provider;
      elements.ollamaUrl.value = state.config.ollamaUrl;
      elements.lmstudioUrl.value = state.config.lmstudioUrl;
      elements.geminiApiKey.value = state.config.geminiApiKey;
      elements.geminiModel.value = state.config.geminiModel;
      elements.openaiApiKey.value = state.config.openaiApiKey;
      elements.openaiModel.value = state.config.openaiModel;
      elements.systemPrompt.value = state.config.systemPrompt;
      updateProviderBadge();
      updateProviderConfigVisibility();
    }

    function updateConfigFromUI() {
      state.config.provider = elements.providerSelect.value;
      state.config.ollamaUrl = elements.ollamaUrl.value;
      state.config.ollamaModel = elements.ollamaModel.value || '';
      state.config.lmstudioUrl = elements.lmstudioUrl.value;
      state.config.lmstudioModel = elements.lmstudioModel.value || '';
      state.config.geminiApiKey = elements.geminiApiKey.value;
      state.config.geminiModel = elements.geminiModel.value;
      state.config.openaiApiKey = elements.openaiApiKey.value;
      state.config.openaiModel = elements.openaiModel.value;
      state.config.systemPrompt = elements.systemPrompt.value || DEFAULT_SYSTEM_PROMPT;
    }

    function updateProviderBadge() {
      const names = { ollama: 'Ollama', lmstudio: 'LM Studio', gemini: 'Gemini', openai: 'OpenAI' };
      elements.providerBadge.textContent = names[state.config.provider] || state.config.provider;
    }

    function updateProviderConfigVisibility() {
      const configs = ['ollama', 'lmstudio', 'gemini', 'openai'];
      configs.forEach(p => {
        const el = elements[`${p}Config`];
        if (el) {
          el.classList.toggle('active', p === state.config.provider);
        }
      });
    }

    // ===== Ollama Models =====
    async function fetchOllamaModels() {
      const url = state.config.ollamaUrl || elements.ollamaUrl.value;
      const select = elements.ollamaModel;
      const hint = elements.ollamaModelHint;
      const refreshBtn = elements.refreshModelsBtn;
      
      refreshBtn.classList.add('loading');
      select.innerHTML = '<option value="">Loading models...</option>';
      hint.textContent = 'Fetching available models from Ollama...';
      hint.className = 'form-hint';

      try {
        const res = await fetch(`${url}/api/tags`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        const models = data.models || [];

        if (models.length === 0) {
          select.innerHTML = '<option value="">No models found</option>';
          hint.textContent = 'No models installed. Run: ollama pull llama3';
          hint.className = 'form-hint error';
          return;
        }

        select.innerHTML = models.map(m => {
          const name = m.name;
          const size = m.size ? ` (${formatBytes(m.size)})` : '';
          return `<option value="${name}">${name}${size}</option>`;
        }).join('');

        if (state.config.ollamaModel) {
          const exists = models.some(m => m.name === state.config.ollamaModel);
          if (exists) select.value = state.config.ollamaModel;
        }

        hint.textContent = `${models.length} model${models.length !== 1 ? 's' : ''} available`;
        hint.className = 'form-hint success';

      } catch (error) {
        console.error('Failed to fetch Ollama models:', error);
        select.innerHTML = '<option value="">Failed to connect</option>';
        hint.textContent = 'Cannot connect to Ollama. Make sure it\'s running with OLLAMA_ORIGINS=*';
        hint.className = 'form-hint error';
      } finally {
        refreshBtn.classList.remove('loading');
      }
    }

    // ===== LM Studio Models =====
    async function fetchLmstudioModels() {
      const url = state.config.lmstudioUrl || elements.lmstudioUrl.value;
      const select = elements.lmstudioModel;
      const hint = elements.lmstudioModelHint;
      const refreshBtn = elements.refreshLmstudioModelsBtn;
      
      refreshBtn.classList.add('loading');
      select.innerHTML = '<option value="">Loading models...</option>';
      hint.textContent = 'Fetching available models from LM Studio...';
      hint.className = 'form-hint';

      try {
        const res = await fetch(`${url}/v1/models`, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        const models = data.data || [];

        if (models.length === 0) {
          select.innerHTML = '<option value="">No models loaded</option>';
          hint.textContent = 'Load a model in LM Studio first';
          hint.className = 'form-hint error';
          return;
        }

        select.innerHTML = models.map(m => {
          return `<option value="${m.id}">${m.id}</option>`;
        }).join('');

        if (state.config.lmstudioModel) {
          const exists = models.some(m => m.id === state.config.lmstudioModel);
          if (exists) select.value = state.config.lmstudioModel;
        }

        hint.textContent = `${models.length} model${models.length !== 1 ? 's' : ''} available`;
        hint.className = 'form-hint success';

      } catch (error) {
        console.error('Failed to fetch LM Studio models:', error);
        select.innerHTML = '<option value="">Failed to connect</option>';
        hint.textContent = 'Cannot connect to LM Studio. Start the local server first.';
        hint.className = 'form-hint error';
      } finally {
        refreshBtn.classList.remove('loading');
      }
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    // ===== Speech Recognition =====
    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) return;

      state.recognition = new SpeechRecognition();
      state.recognition.continuous = true;
      state.recognition.interimResults = true;
      state.recognition.lang = 'en-US';

      state.recognition.onstart = () => {
        state.isRecording = true;
        elements.recordBtn.classList.add('recording');
        elements.recordBtnText.textContent = 'Stop';
        elements.transcriptOverlay.classList.add('active');
        elements.transcriptContent.classList.remove('empty');
      };

      state.recognition.onend = () => {
        state.isRecording = false;
        elements.recordBtn.classList.remove('recording');
        elements.recordBtnText.textContent = 'Record';
        
        if (!state.isProcessing && !state.transcript.trim()) {
          elements.transcriptOverlay.classList.remove('active');
        }
      };

      state.recognition.onresult = (event) => {
        let interim = '';
        let final = '';

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            final += transcript;
          } else {
            interim += transcript;
          }
        }

        if (final) {
          state.transcript += final;
        }
        state.interimTranscript = interim;

        updateTranscriptDisplay();
      };

      state.recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        if (event.error === 'not-allowed') {
          showToast('Microphone access denied. Please allow microphone access.', 'error');
        } else if (event.error !== 'aborted') {
          showToast(`Recognition error: ${event.error}`, 'error');
        }
      };
    }

    function toggleRecording() {
      if (state.isProcessing) return;

      if (state.isRecording) {
        state.recognition.stop();
      } else {
        state.transcript = '';
        state.interimTranscript = '';
        elements.transcriptContent.innerHTML = 'Start speaking...';
        elements.transcriptContent.classList.add('empty');
        try {
          state.recognition.start();
        } catch (e) {
          // Already started, ignore
        }
      }
    }

    function updateTranscriptDisplay() {
      const content = state.transcript + 
        (state.interimTranscript ? `<span class="interim">${state.interimTranscript}</span>` : '');
      
      if (content) {
        elements.transcriptContent.innerHTML = content;
        elements.transcriptContent.classList.remove('empty');
      } else {
        elements.transcriptContent.textContent = 'Start speaking...';
        elements.transcriptContent.classList.add('empty');
      }
    }

    // ===== AI Integration =====
    async function sendToAI(text) {
      if (!text.trim()) {
        showToast('No transcript to send', 'error');
        return;
      }

      // Hide transcript overlay and show loading
      elements.transcriptOverlay.classList.remove('active');
      state.isProcessing = true;
      elements.responseContent.innerHTML = '<span class="loading-dots">Thinking</span>';
      elements.responseContent.classList.remove('empty');
      elements.responseContent.classList.add('loading');

      try {
        let response;
        const systemPrompt = state.config.systemPrompt;

        switch (state.config.provider) {
          case 'ollama':
            response = await sendToOllama(text, systemPrompt);
            break;
          case 'lmstudio':
            response = await sendToLmstudio(text, systemPrompt);
            break;
          case 'gemini':
            response = await sendToGemini(text, systemPrompt);
            break;
          case 'openai':
            response = await sendToOpenAI(text, systemPrompt);
            break;
          default:
            throw new Error('Unknown provider');
        }

        // Add to history
        state.history.push({
          timestamp: Date.now(),
          transcript: text,
          response: response,
          provider: state.config.provider
        });
        state.historyIndex = state.history.length - 1;
        saveSettings();

        displayResponse(response);
        updateHistoryNav();

      } catch (error) {
        console.error('AI request failed:', error);
        showToast(error.message || 'Failed to get AI response', 'error');
        elements.responseContent.textContent = 'Error: ' + (error.message || 'Request failed');
        elements.responseContent.classList.remove('loading');
      } finally {
        state.isProcessing = false;
      }
    }

    async function sendToOllama(text, systemPrompt) {
      if (!state.config.ollamaModel) {
        throw new Error('No Ollama model selected. Please configure in Settings.');
      }

      const url = `${state.config.ollamaUrl}/api/generate`;
      const prompt = systemPrompt ? `${systemPrompt}\n\nUser: ${text}` : text;

      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: state.config.ollamaModel,
          prompt: prompt,
          stream: false
        })
      });

      if (!res.ok) {
        throw new Error(`Ollama error: ${res.status} ${res.statusText}`);
      }

      const data = await res.json();
      return data.response;
    }

    async function sendToLmstudio(text, systemPrompt) {
      if (!state.config.lmstudioModel) {
        throw new Error('No LM Studio model selected. Please configure in Settings.');
      }

      const messages = [];
      if (systemPrompt) {
        messages.push({ role: 'system', content: systemPrompt });
      }
      messages.push({ role: 'user', content: text });

      const res = await fetch(`${state.config.lmstudioUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: state.config.lmstudioModel,
          messages: messages
        })
      });

      if (!res.ok) {
        throw new Error(`LM Studio error: ${res.status} ${res.statusText}`);
      }

      const data = await res.json();
      return data.choices?.[0]?.message?.content || 'No response';
    }

    async function sendToGemini(text, systemPrompt) {
      if (!state.config.geminiApiKey) {
        throw new Error('Gemini API key not configured');
      }

      const model = state.config.geminiModel;
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${state.config.geminiApiKey}`;
      
      const contents = [];
      if (systemPrompt) {
        contents.push({ role: 'user', parts: [{ text: systemPrompt }] });
        contents.push({ role: 'model', parts: [{ text: 'Understood.' }] });
      }
      contents.push({ role: 'user', parts: [{ text }] });

      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ contents })
      });

      if (!res.ok) {
        const error = await res.json().catch(() => ({}));
        throw new Error(error.error?.message || `Gemini error: ${res.status}`);
      }

      const data = await res.json();
      return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    }

    async function sendToOpenAI(text, systemPrompt) {
      if (!state.config.openaiApiKey) {
        throw new Error('OpenAI API key not configured');
      }

      const messages = [];
      if (systemPrompt) {
        messages.push({ role: 'system', content: systemPrompt });
      }
      messages.push({ role: 'user', content: text });

      const res = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${state.config.openaiApiKey}`
        },
        body: JSON.stringify({
          model: state.config.openaiModel,
          messages: messages
        })
      });

      if (!res.ok) {
        const error = await res.json().catch(() => ({}));
        throw new Error(error.error?.message || `OpenAI error: ${res.status}`);
      }

      const data = await res.json();
      return data.choices?.[0]?.message?.content || 'No response';
    }

    function displayResponse(text) {
      elements.responseContent.textContent = text;
      elements.responseContent.classList.remove('empty', 'loading');
    }

    // ===== History Navigation =====
    function updateHistoryNav() {
      if (state.history.length > 0) {
        elements.historyNav.classList.remove('hidden');
        elements.historyCounter.textContent = `${state.historyIndex + 1} / ${state.history.length}`;
        elements.prevBtn.disabled = state.historyIndex <= 0;
        elements.nextBtn.disabled = state.historyIndex >= state.history.length - 1;
      } else {
        elements.historyNav.classList.add('hidden');
      }
    }

    function navigateHistory(direction) {
      if (state.history.length === 0) return;

      const newIndex = state.historyIndex + direction;
      if (newIndex >= 0 && newIndex < state.history.length) {
        state.historyIndex = newIndex;
        const item = state.history[newIndex];
        displayResponse(item.response);
        updateHistoryNav();
      }
    }

    // ===== Modals =====
    function openSettings() {
      if (state.isFirstRun) {
        elements.settingsTitle.textContent = 'Setup';
        elements.setupWelcome.classList.remove('hidden');
        elements.saveSettings.textContent = 'Get Started';
      } else {
        elements.settingsTitle.textContent = 'Settings';
        elements.setupWelcome.classList.add('hidden');
        elements.saveSettings.textContent = 'Save Settings';
      }
      
      elements.settingsModal.classList.add('active');
      
      // Fetch models for current provider
      if (state.config.provider === 'ollama') {
        fetchOllamaModels();
      } else if (state.config.provider === 'lmstudio') {
        fetchLmstudioModels();
      }
    }

    function closeSettings() {
      elements.settingsModal.classList.remove('active');
    }

    // ===== Toast =====
    function showToast(message, type = 'error') {
      elements.toast.textContent = message;
      elements.toast.className = `toast ${type} active`;
      
      setTimeout(() => {
        elements.toast.classList.remove('active');
      }, 4000);
    }

    // ===== Cancel Action =====
    function cancelRecording() {
      if (state.isRecording) {
        state.recognition.stop();
      }
      state.transcript = '';
      state.interimTranscript = '';
      elements.transcriptOverlay.classList.remove('active');
    }

    // ===== Keyboard Handler =====
    function handleKeydown(e) {
      // Ignore when typing in inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        if (e.key === 'Escape') {
          e.target.blur();
        }
        return;
      }

      // Close settings modal on Escape
      if (e.key === 'Escape') {
        if (elements.settingsModal.classList.contains('active')) {
          closeSettings();
          e.preventDefault();
          return;
        }
        if (elements.transcriptOverlay.classList.contains('active')) {
          cancelRecording();
          e.preventDefault();
          return;
        }
      }

      switch (e.code) {
        case 'Space':
          e.preventDefault();
          toggleRecording();
          break;
        case 'Enter':
          if (elements.transcriptOverlay.classList.contains('active') && state.transcript.trim()) {
            e.preventDefault();
            if (state.isRecording) state.recognition.stop();
            sendToAI(state.transcript);
          }
          break;
        case 'ArrowUp':
        case 'KeyK':
          e.preventDefault();
          navigateHistory(-1);
          break;
        case 'ArrowDown':
        case 'KeyJ':
          e.preventDefault();
          navigateHistory(1);
          break;
        case 'KeyS':
          if (!e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            openSettings();
          }
          break;
      }
    }

    // ===== Event Listeners =====
    function setupEventListeners() {
      document.addEventListener('keydown', handleKeydown);

      // Record button
      elements.recordBtn.addEventListener('click', toggleRecording);

      // Transcript overlay buttons
      elements.cancelBtn.addEventListener('click', cancelRecording);
      elements.sendBtn.addEventListener('click', () => {
        if (state.transcript.trim()) {
          if (state.isRecording) state.recognition.stop();
          sendToAI(state.transcript);
        }
      });

      // History navigation
      elements.prevBtn.addEventListener('click', () => navigateHistory(-1));
      elements.nextBtn.addEventListener('click', () => navigateHistory(1));

      // Settings Modal
      elements.settingsBtn.addEventListener('click', openSettings);
      elements.settingsClose.addEventListener('click', closeSettings);
      elements.settingsModal.addEventListener('click', (e) => {
        if (e.target === elements.settingsModal) closeSettings();
      });

      // Provider Select
      elements.providerSelect.addEventListener('change', () => {
        state.config.provider = elements.providerSelect.value;
        updateProviderConfigVisibility();
        updateProviderBadge();
        if (state.config.provider === 'ollama') {
          fetchOllamaModels();
        } else if (state.config.provider === 'lmstudio') {
          fetchLmstudioModels();
        }
      });

      // Ollama URL change
      let ollamaUrlTimer;
      elements.ollamaUrl.addEventListener('input', () => {
        clearTimeout(ollamaUrlTimer);
        ollamaUrlTimer = setTimeout(() => {
          state.config.ollamaUrl = elements.ollamaUrl.value;
          fetchOllamaModels();
        }, 800);
      });

      elements.refreshModelsBtn.addEventListener('click', () => {
        state.config.ollamaUrl = elements.ollamaUrl.value;
        fetchOllamaModels();
      });

      // LM Studio URL change
      let lmstudioUrlTimer;
      elements.lmstudioUrl.addEventListener('input', () => {
        clearTimeout(lmstudioUrlTimer);
        lmstudioUrlTimer = setTimeout(() => {
          state.config.lmstudioUrl = elements.lmstudioUrl.value;
          fetchLmstudioModels();
        }, 800);
      });

      elements.refreshLmstudioModelsBtn.addEventListener('click', () => {
        state.config.lmstudioUrl = elements.lmstudioUrl.value;
        fetchLmstudioModels();
      });

      // Save Settings
      elements.saveSettings.addEventListener('click', () => {
        updateConfigFromUI();
        saveSettings();
        updateProviderBadge();
        closeSettings();
        showToast('Settings saved', 'success');
        state.isFirstRun = false;
      });
    }

    // ===== Service Worker Registration =====
    async function registerServiceWorker() {
      if ('serviceWorker' in navigator) {
        try {
          await navigator.serviceWorker.register('./sw.js');
        } catch (e) {
          console.error('Service worker registration failed:', e);
        }
      }
    }

    // ===== PWA Install Prompt =====
    let deferredPrompt = null;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
    });

    // ===== Initialize =====
    function init() {
      if (!checkBrowserSupport()) return;

      loadSettings();
      initSpeechRecognition();
      setupEventListeners();
      registerServiceWorker();
      updateHistoryNav();

      // Show setup screen on first run
      if (state.isFirstRun) {
        openSettings();
        setTimeout(() => {
          if (state.config.provider === 'ollama') {
            fetchOllamaModels();
          } else if (state.config.provider === 'lmstudio') {
            fetchLmstudioModels();
          }
        }, 300);
      }
    }

    init();
  </script>
</body>
</html>
